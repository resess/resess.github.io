<!DOCTYPE html><html lang="en-US">

<head>
    <meta charset="UTF-8">
    <title>Expert Developer 2 - Scenario 2 observational notes</title>
    <link rel="stylesheet" href="../../../assets/css/just-the-docs.css"> 
    <link rel="stylesheet" href="../../../assets/css/h4-override.css">
    <script type="text/javascript" src="../../../assets/js/vendor/lunr.min.js"></script> 
    <script type="text/javascript" src="../../../assets/js/just-the-docs.js"></script>
    <script type="text/javascript" src="../../../assets/js/navigation.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

<body>
    <div class="page-wrap">
        <div class="side-bar">
            <div class="site-header"> 
                <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button>
            </div>
            <div class="navigation main-nav js-main-nav">
                <!-- Navigation will be dynamically generated by navigation.js -->
            </div>
            <footer class="site-footer">
                <p class="text-small text-grey-dk-000 mb-4">FSE 2026</p>
            </footer>
        </div>
        <div class="main-content-wrap js-main-content" tabindex="0">
            <div class="main-content">
                <div class="page-header js-page-header">
                    <div class="search">
                        <div class="search-input-wrap"> 
                            <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search " aria-label="Search " autocomplete="off"> 
                            <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon">
                                <title>Search</title> 
                                <g fill-rule="nonzero">
                                    <path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z" />
                                    <path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z" />
                                </g>
                            </svg>
                        </div>
                        <div class="js-search-results search-results-wrap"></div>
                    </div>
                </div>
                <div class="page">
                    <div id="main-content" class="page-content" role="main">
                        <!-- Main Content of the Page Starts-->
                        <h1 id="scenario-1-observational-notes">Expert Developer 2: Scenario 2 Observational Notes</h1>
<p>This scenario evaluates the code generation when frontend and backend are generated separately. The observations reveal improvements in architecture and structure, but also persistent and new issues in code quality, security, and maintainability.</p>
<hr>
<p><strong>Code Generation Order</strong></p>
<p>Cursor implements both the frontend and the backend in a sequential buttom-up style.</p>
<p>Having the backend generated first and having it in the code base provides cursor with context before doing the frotend.</p>
<p><strong>Separation of Frontend &amp; Backend</strong></p>
<p>+ Looking at the generation flow. I see that separating the tech stack used by the model has a positive affect on the model. I remember reading a paper which suggested different model neurons get activated for different programming languages, therefore not switching between these nuerons seems to have a positive effect.</p>
<p>- The separation of FE/BE while mostly benificial came with some challenges. For instance, integeration is now a new concern for the model which should be handled when generating the frontend using the provided docs by the backend generation. While this adds complexity I don&#39;t see it be worse than scenario 1, mainly because scenario 1 didn&#39;t do a really bad job at integration.</p>
<hr>
<p><strong>Better Backend Architecture</strong></p>
<p>The backend shows improved structure with a proper controller layer—routes now only handle routing:</p>
<pre><code>├───<span class="hljs-built_in">config</span>
├───controllers*
├───docs
├───middlewares
├───models
├───routes
├───services
├───types
└───utils
</code></pre><p><strong>Rate Limiting Middleware</strong></p>
<p>Implementing the backend alone allowed the model to consider additional concerns. For instance, rate limiting middleware was added:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiLimiter = rateLimit({
  <span class="hljs-attr">windowMs</span>: env.RATE_LIMIT_WINDOW_MS, <span class="hljs-comment">// 15 minutes</span>
  max: env.RATE_LIMIT_MAX_REQUESTS, <span class="hljs-comment">// limit each IP to 100 requests per windowMs</span>
  message: {
    <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">error</span>: <span class="hljs-string">'Too many requests from this IP, please try again later.'</span>,
    <span class="hljs-attr">retryAfter</span>: <span class="hljs-built_in">Math</span>.ceil(env.RATE_LIMIT_WINDOW_MS / <span class="hljs-number">1000</span>)
  },
  <span class="hljs-attr">standardHeaders</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Return rate limit info in the `RateLimit-*` headers</span>
  legacyHeaders: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Disable the `X-RateLimit-*` headers</span>
  handler: <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    logger.warn(<span class="hljs-string">`Rate limit exceeded for IP: <span class="hljs-subst">${req.ip}</span>`</span>);
    res.status(<span class="hljs-number">429</span>).json({
      <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">error</span>: <span class="hljs-string">'Too many requests from this IP, please try again later.'</span>,
      <span class="hljs-attr">retryAfter</span>: <span class="hljs-built_in">Math</span>.ceil(env.RATE_LIMIT_WINDOW_MS / <span class="hljs-number">1000</span>)
    });
  }
});
</code></pre><p><strong>Improved Environment Variable Handling</strong></p>
<p>Environment variables are handled much better with a dedicated configuration file instead of being handled inline where needed:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> EnvironmentConfig {
  <span class="hljs-comment">// Server Configuration</span>
  PORT: <span class="hljs-built_in">number</span>;
  NODE_ENV: <span class="hljs-built_in">string</span>;
  API_VERSION: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// Database Configuration</span>
  MONGODB_URI: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// Authentication Configuration</span>
  JWT_SECRET: <span class="hljs-built_in">string</span>;
  JWT_EXPIRES_IN: <span class="hljs-built_in">string</span>;
  GOOGLE_CLIENT_ID: <span class="hljs-built_in">string</span>;
  GOOGLE_CLIENT_SECRET: <span class="hljs-built_in">string</span>;
  FACEBOOK_APP_ID: <span class="hljs-built_in">string</span>;
  FACEBOOK_APP_SECRET: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// External APIs</span>
  TMDB_API_KEY: <span class="hljs-built_in">string</span>;
  TMDB_BASE_URL: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// CORS Configuration</span>
  ALLOWED_ORIGINS: <span class="hljs-built_in">string</span>[];

  <span class="hljs-comment">// Rate Limiting</span>
  RATE_LIMIT_WINDOW_MS: <span class="hljs-built_in">number</span>;
  RATE_LIMIT_MAX_REQUESTS: <span class="hljs-built_in">number</span>;

  <span class="hljs-comment">// WebSocket Configuration</span>
  WEBSOCKET_CORS_ORIGINS: <span class="hljs-built_in">string</span>[];

  <span class="hljs-comment">// Logging</span>
  LOG_LEVEL: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// Security</span>
  BCRYPT_SALT_ROUNDS: <span class="hljs-built_in">number</span>;

  <span class="hljs-comment">// Session Configuration</span>
  SESSION_TIMEOUT_MS: <span class="hljs-built_in">number</span>;
  INVITATION_CODE_LENGTH: <span class="hljs-built_in">number</span>;
}
</code></pre><p><strong>Additional Functionality</strong></p>
<p>There are also new routes that might not be essential but demonstrate the model&#39;s freedom to explore more functionality when frontend and backend are prompted separately:</p>
<pre><code> <span class="hljs-comment">// Check if user can start voting session</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> canStartVoting = asyncHandler(<span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
    <span class="hljs-keyword">const</span> user = req.user!;
    <span class="hljs-keyword">const</span> { groupId } = req.<span class="hljs-keyword">params</span>;

    <span class="hljs-keyword">if</span> (!groupId) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidationError(<span class="hljs-string">'Group ID is required'</span>);
    }

    <span class="hljs-keyword">const</span> canStart = <span class="hljs-keyword">await</span> groupService.canStartVoting(groupId, user._id.toString());

    <span class="hljs-keyword">const</span> response: ApiResponse = {
      success: <span class="hljs-literal">true</span>,
      data: { canStartVoting: canStart },
      message: canStart ? <span class="hljs-string">'Can start voting session'</span> : <span class="hljs-string">'Cannot start voting session - not all members have set preferences'</span>
    };

    res.json(response);
  });
</code></pre><hr>
<p><strong>Backend Issues</strong></p>
<p>Despite some advancements there are new issues as well as some issues already seen in scenario 1.</p>
<p><strong>Unused Imports</strong></p>
<p>There are some unused imports; for example, the logger and some error classes are imported but never used.</p>
<p><img src="../../../data/rq2/observational-notes/expert2/data/scenario2/image1.png" alt="" width="800"><br></p>
<p><strong>Security Vulnerabilities in Dependencies</strong></p>
<p>Despite architectural improvements, new issues emerged:</p>
<pre><code><span class="hljs-number">85</span> packages are looking for funding
  <span class="hljs-keyword">run</span><span class="bash"> `npm fund` <span class="hljs-keyword">for</span> details
</span>
<span class="hljs-number">2</span> vulnerabilities (<span class="hljs-number">1</span> moderate, <span class="hljs-number">1</span> high)
</code></pre><p><strong>Build Errors</strong></p>
<p>The code is still not runnable due to TypeScript errors:</p>
<pre><code><span class="hljs-number">234</span>       const vote = session.getUserVoteForMovie(userId, movieId);
                               ~~~~~~~~~~~~~~~~~~~


Found <span class="hljs-number">27</span> errors <span class="hljs-keyword">in</span> <span class="hljs-number">6</span> files.

Errors  Files
     <span class="hljs-number">3</span>  src<span class="hljs-regexp">/middlewares/</span>auth.<span class="hljs-string">ts:</span><span class="hljs-number">87</span>
     <span class="hljs-number">7</span>  src<span class="hljs-regexp">/models/</span>Group.<span class="hljs-string">ts:</span><span class="hljs-number">58</span>
     <span class="hljs-number">2</span>  src<span class="hljs-regexp">/models/</span>User.<span class="hljs-string">ts:</span><span class="hljs-number">44</span>
     <span class="hljs-number">7</span>  src<span class="hljs-regexp">/models/</span>VotingSession.<span class="hljs-string">ts:</span><span class="hljs-number">137</span>
     <span class="hljs-number">5</span>  src<span class="hljs-regexp">/services/</span>GroupService.<span class="hljs-string">ts:</span><span class="hljs-number">116</span>
     <span class="hljs-number">3</span>  src<span class="hljs-regexp">/services/</span>VotingService.<span class="hljs-string">ts:</span><span class="hljs-number">130</span>
</code></pre><p><strong>REST Convention Misuse</strong></p>
<p>Using POST instead of DELETE for leave operations:</p>
<pre><code><span class="hljs-comment">// Group membership</span>
<span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.post</span>(<span class="hljs-string">'/:groupId/preferences'</span>, GroupController.setPreferences);
<span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.delete</span>(<span class="hljs-string">'/:groupId/members'</span>, GroupController.removeMember);
<span class="hljs-selector-tag">router</span><span class="hljs-selector-class">.post</span>(<span class="hljs-string">'/:groupId/leave'</span>, GroupController.leaveGroup);
</code></pre><p><strong>Deprecated Code</strong></p>
<p>Using deprecated <code>substr</code> instead of <code>substring</code>:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSessionId</span>(<span class="hljs-params"></span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'session_'</span> + <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>) + <span class="hljs-string">'_'</span> + <span class="hljs-built_in">Date</span>.now().toString(<span class="hljs-number">36</span>);
}
</code></pre><p><strong>Incomplete/Placeholder Code</strong></p>
<p>Code written for future use with no actual implementation:</p>
<pre><code><span class="hljs-comment">// Admin middleware (for future use)</span>
<span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">requireAdmin</span>(<span class="hljs-attribute">req</span>: Request, <span class="hljs-attribute">res</span>: Response, <span class="hljs-attribute">next</span>: NextFunction): <span class="hljs-selector-tag">void</span> {
  <span class="hljs-selector-tag">if</span> (!req.user) {
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.status</span>(<span class="hljs-number">401</span>)<span class="hljs-selector-class">.json</span>({
      <span class="hljs-attribute">success</span>: false,
      <span class="hljs-attribute">error</span>: <span class="hljs-string">'Unauthorized: Authentication required'</span>
    });
  }

  <span class="hljs-comment">// For now, all authenticated users are considered admins</span>
  <span class="hljs-comment">// In a real app, you'd check user roles here</span>
  next();
}
</code></pre><p><strong>Persistent Security Issues</strong></p>
<p>JWT fallback values remain a security concern:</p>
<pre><code>JWT_SECRET: <span class="hljs-built_in">process</span>.env.JWT_SECRET || <span class="hljs-string">'your-super-secret-jwt-key-change-in-production'</span>,
JWT_EXPIRES_IN: <span class="hljs-built_in">process</span>.env.JWT_EXPIRES_IN || <span class="hljs-string">'7d'</span>,
</code></pre><p><strong>Input Validation Issues</strong></p>
<p>Input validations are not centralized using deserializers; instead, each controller performs ad-hoc validation:</p>
<pre><code><span class="hljs-keyword">if</span> (!groupData.<span class="hljs-built_in">name</span> || groupData.<span class="hljs-built_in">name</span>.trim().<span class="hljs-built_in">length</span> === <span class="hljs-number">0</span>) {
      throw new ValidationError('Group <span class="hljs-built_in">name</span> <span class="hljs-keyword">is</span> required');
    }
</code></pre><p><strong>Missing Caching</strong></p>
<p>There&#39;s no caching for external API calls, which is a performance issue.</p>
<hr>
<p><strong>More Complete Implementation of Frontend</strong></p>
<p>The frontend is performing much better than what was observed in Scenario 1. There are more files generated and functionalities are more complete.</p>
<p><strong>User Data Persistence</strong></p>
<p>For instance, there&#39;s a class to save user&#39;s data and token:</p>
<pre><code><span class="hljs-meta">@Singleton</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPreferencesDataStore</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(
    <span class="hljs-meta">@ApplicationContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context
) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">object</span> PreferencesKeys {
        <span class="hljs-keyword">val</span> AUTH_TOKEN = stringPreferencesKey(<span class="hljs-string">"auth_token"</span>)
        <span class="hljs-keyword">val</span> USER_ID = stringPreferencesKey(<span class="hljs-string">"user_id"</span>)
        <span class="hljs-keyword">val</span> USER_NAME = stringPreferencesKey(<span class="hljs-string">"user_name"</span>)
        <span class="hljs-keyword">val</span> USER_EMAIL = stringPreferencesKey(<span class="hljs-string">"user_email"</span>)
        <span class="hljs-keyword">val</span> PROFILE_PICTURE_URL = stringPreferencesKey(<span class="hljs-string">"profile_picture_url"</span>)
    }
</code></pre><p><em>Note: The code adds functionality but is insecure as it doesn&#39;t encrypt the saved token (EncryptedSharedPreferences should be used instead).</em></p>
<p><strong>Improved Architecture</strong></p>
<p>There&#39;s a new repository layer over the datasources (similar improvement as what the backend received). This demonstrates that separating concerns allows the model to think more about non-functional aspects like code structure and architectural design. ViewModels are now present to handle state management.</p>
<hr>
<p><strong>Frontend Issues</strong></p>
<p><strong>Degraded File Organization</strong></p>
<p>Despite some improvements, some other things got worse. In Scenario 1, there was a by-feature separation in the Screens folder which is now lost. Screen files are laid flat, which is less maintainable:</p>
<p><strong>Scenario 1 (better):</strong></p>
<pre><code>Screens
│      auth
│      groups
│      <span class="hljs-built_in">home</span>
│      voting
</code></pre><p><strong>Scenario 2 (worse):</strong></p>
<pre><code>Screens:
│       CreateGroupScreen<span class="hljs-selector-class">.kt</span>
│       GenreSelectionScreen<span class="hljs-selector-class">.kt</span>
│       GroupDetailsScreen<span class="hljs-selector-class">.kt</span>
│       GroupListScreen<span class="hljs-selector-class">.kt</span>
│       HomeScreen<span class="hljs-selector-class">.kt</span>
│       JoinGroupScreen<span class="hljs-selector-class">.kt</span>
│       LoginScreen<span class="hljs-selector-class">.kt</span>
│       MovieResultScreen<span class="hljs-selector-class">.kt</span>
│       VotingScreen.kt
</code></pre><p><strong>Build Failures</strong></p>
<p>The frontend code does not build successfully due to multiple configuration issues (dependency issues) and unresolved references.</p>
<p><strong>Deprecated Icons</strong></p>
<p>Using deprecated icons:</p>
<pre><code>import androidx<span class="hljs-selector-class">.compose</span><span class="hljs-selector-class">.material</span><span class="hljs-selector-class">.icons</span><span class="hljs-selector-class">.filled</span><span class="hljs-selector-class">.ArrowBack</span>
</code></pre><p><strong>Magic Numbers</strong></p>
<p>Magic numbers used throughout the code:</p>
<pre><code><span class="hljs-keyword">if</span> (abs(offsetX) &gt; <span class="hljs-number">50f</span>) {  <span class="hljs-comment">// Magic number</span>
                SwipeIndicator(
                    isLike = offsetX &gt; <span class="hljs-number">0</span>,
                    alpha = (abs(offsetX) / <span class="hljs-number">200f</span>).coerceAtMost(<span class="hljs-number">1f</span>)
                )
            }
</code></pre><pre><code>               <span class="hljs-attr">translationX</span> = offsetX,
                <span class="hljs-attr">translationY</span> = offsetY,
                <span class="hljs-attr">rotationZ</span> = offsetX / <span class="hljs-number">20</span>f
</code></pre><p><strong>Incomplete Error Handling</strong></p>
<p>Error handling is incomplete with placeholder comments:</p>
<pre><code>            <span class="hljs-comment">// Error handling</span>
            uiState.<span class="hljs-built_in">error</span>?.<span class="hljs-keyword">let</span> { <span class="hljs-built_in">error</span> -&gt;
                LaunchedEffect(<span class="hljs-built_in">error</span>) {
                    <span class="hljs-comment">// Show error (could use SnackbarHost in a real app)</span>
                }
            }
</code></pre><p><strong>Unused Imports</strong></p>
<p><img src="../../../data/rq2/observational-notes/expert2/data/scenario2/image2.png" alt="" width="800"><br></p>
<p><strong>Repeated Error Handling Pattern</strong></p>
<p>Same error handling pattern copied throughout the codebase (The error handling is also generic):</p>
<pre><code>suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUserGroups</span><span class="hljs-params">()</span></span>: Resource&lt;List&lt;Group&gt;&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> response = apiService.getUserGroups()
            <span class="hljs-keyword">if</span> (response.isSuccessful &amp;&amp; response.body()?.success == <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">val</span> groups = response.body()?.<span class="hljs-keyword">data</span> ?: emptyList()
                Resource.Success(groups)
            } <span class="hljs-keyword">else</span> {
                Resource.Error(response.body()?.message ?: <span class="hljs-string">"Failed to get groups"</span>)
            }
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Resource.Error(e.message ?: <span class="hljs-string">"Network error"</span>)
        }
    }

    suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createGroup</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, description: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span>: Resource&lt;Group&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> request = CreateGroupRequest(name, description)
            <span class="hljs-keyword">val</span> response = apiService.createGroup(request)
            <span class="hljs-keyword">if</span> (response.isSuccessful &amp;&amp; response.body()?.success == <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">val</span> group = response.body()?.<span class="hljs-keyword">data</span>
                <span class="hljs-keyword">if</span> (group != <span class="hljs-literal">null</span>) {
                    Resource.Success(group)
                } <span class="hljs-keyword">else</span> {
                    Resource.Error(<span class="hljs-string">"Group data is null"</span>)
                }
            } <span class="hljs-keyword">else</span> {
                Resource.Error(response.body()?.message ?: <span class="hljs-string">"Failed to create group"</span>)
            }
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Resource.Error(e.message ?: <span class="hljs-string">"Network error"</span>)
        }
    }

    suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinGroup</span><span class="hljs-params">(invitationCode: <span class="hljs-type">String</span>)</span></span>: Resource&lt;Group&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> request = JoinGroupRequest(invitationCode)
            <span class="hljs-keyword">val</span> response = apiService.joinGroup(request)
            <span class="hljs-keyword">if</span> (response.isSuccessful &amp;&amp; response.body()?.success == <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">val</span> group = response.body()?.<span class="hljs-keyword">data</span>
                <span class="hljs-keyword">if</span> (group != <span class="hljs-literal">null</span>) {
                    Resource.Success(group)
                } <span class="hljs-keyword">else</span> {
                    Resource.Error(<span class="hljs-string">"Group data is null"</span>)
                }
            } <span class="hljs-keyword">else</span> {
                Resource.Error(response.body()?.message ?: <span class="hljs-string">"Failed to join group"</span>)
            }
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Resource.Error(e.message ?: <span class="hljs-string">"Network error"</span>)
        }
    }

    suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getGroupDetails</span><span class="hljs-params">(groupId: <span class="hljs-type">String</span>)</span></span>: Resource&lt;Group&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> response = apiService.getGroupDetails(groupId)
            <span class="hljs-keyword">if</span> (response.isSuccessful &amp;&amp; response.body()?.success == <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">val</span> group = response.body()?.<span class="hljs-keyword">data</span>
                <span class="hljs-keyword">if</span> (group != <span class="hljs-literal">null</span>) {
                    Resource.Success(group)
                } <span class="hljs-keyword">else</span> {
                    Resource.Error(<span class="hljs-string">"Group data is null"</span>)
                }
            } <span class="hljs-keyword">else</span> {
                Resource.Error(response.body()?.message ?: <span class="hljs-string">"Failed to get group details"</span>)
            }
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Resource.Error(e.message ?: <span class="hljs-string">"Network error"</span>)
        }
    }
</code></pre><p><strong>Hardcoded URLs</strong></p>
<pre><code>    <span class="hljs-variable">@Provides</span>
    <span class="hljs-variable">@Singleton</span>
    fun provideRetrofit(
        <span class="hljs-attribute">okHttpClient</span>: OkHttpClient,
        <span class="hljs-attribute">moshi</span>: Moshi
    ): Retrofit {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Retrofit</span><span class="hljs-selector-class">.Builder</span>()
            <span class="hljs-selector-class">.baseUrl</span>(<span class="hljs-string">"http://localhost:3000/api/v1/"</span>) <span class="hljs-comment">// Development server</span>
            <span class="hljs-selector-class">.client</span>(okHttpClient)
            <span class="hljs-selector-class">.addConverterFactory</span>(MoshiConverterFactory.create(moshi))
            <span class="hljs-selector-class">.build</span>()
    }
</code></pre><hr>
<p><strong>Integration: Enum Mismatch Between Frontend and Backend</strong></p>
<p>Incorrect implementations causing integration issues. The enum for voting status in the backend:</p>
<pre><code>export <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">VotingStatus</span> {</span>
  WAITING = <span class="hljs-string">"waiting"</span>,
  ACTIVE = <span class="hljs-string">"active"</span>,
  COMPLETED = <span class="hljs-string">"completed"</span>,
  CANCELLED = <span class="hljs-string">"cancelled"</span>
}
</code></pre><p>But the frontend uses:</p>
<pre><code><span class="hljs-selector-tag">enum</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">VotingStatus</span> {
    <span class="hljs-variable">@Json</span>(name = <span class="hljs-string">"active"</span>) ACTIVE,
    <span class="hljs-variable">@Json</span>(name = <span class="hljs-string">"ended"</span>) ENDED  <span class="hljs-comment">// Should be "completed"!</span>
}
</code></pre><p>This represents a significant integration and consistency issue.</p>
<hr>
<p><strong>Authorization Check</strong></p>
<p>Something better than Scenario 1: there&#39;s now a check to show the start voting button only to the group owner.</p>
<hr>
<p><strong>Personal Take</strong></p>
<p>There are more things that make sense with the generation now. Separating frontend and backend is the way to go in many settings either it be a group project or a big tech company. Splitting work by technical stack allows developers (and as it seems AI agents) to focus more deeply on their task. The model can have more context for each prompt and therefore it can genearte more code. </p>
<p>That said the code is still hardly understandable and difficult to run/build/fix. Separation helps the model focus, but doesn&#39;t eliminate the need for careful human review and A LOT OF manual fixes. I would still rather just throw this code away and start coding myself. </p>


                        <!-- Main Content of the Page Ends-->
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>