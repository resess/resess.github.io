<!DOCTYPE html><html lang="en-US">

<head>
    <meta charset="UTF-8">
    <title>Expert Developer 2 - Scenario 1 observational notes</title>
    <link rel="stylesheet" href="../../../assets/css/just-the-docs.css"> 
    <link rel="stylesheet" href="../../../assets/css/h4-override.css">
    <script type="text/javascript" src="../../../assets/js/vendor/lunr.min.js"></script> 
    <script type="text/javascript" src="../../../assets/js/just-the-docs.js"></script>
    <script type="text/javascript" src="../../../assets/js/navigation.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

<body>
    <div class="page-wrap">
        <div class="side-bar">
            <div class="site-header"> 
                <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button>
            </div>
            <div class="navigation main-nav js-main-nav">
                <!-- Navigation will be dynamically generated by navigation.js -->
            </div>
            <footer class="site-footer">
                <p class="text-small text-grey-dk-000 mb-4">FSE 2026</p>
            </footer>
        </div>
        <div class="main-content-wrap js-main-content" tabindex="0">
            <div class="main-content">
                <div class="page-header js-page-header">
                    <div class="search">
                        <div class="search-input-wrap"> 
                            <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search " aria-label="Search " autocomplete="off"> 
                            <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon">
                                <title>Search</title> 
                                <g fill-rule="nonzero">
                                    <path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z" />
                                    <path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z" />
                                </g>
                            </svg>
                        </div>
                        <div class="js-search-results search-results-wrap"></div>
                    </div>
                </div>
                <div class="page">
                    <div id="main-content" class="page-content" role="main">
                        <!-- Main Content of the Page Starts-->
                        <h1 id="scenario-1-observational-notes">Expert Developer 2: Scenario 1 Observational Notes</h1>
<p>This scenario evaluates the code generation when both frontend and backend are generated together in a single prompt. The observations highlight issues related to code structure (architecture), completeness, unnecessary code, security, and quality.</p>
<hr>
<p><strong>Code Generation Order</strong></p>
<p>Generation starts with the backend, specifically generating the <code>package.json</code> and the main <code>index.ts</code> file, then filling in the missing components (routes, database connections, etc.).</p>
<p>The generation and planning process looks reasonable at first glance:</p>
<p>Configuration (package.json, tsconfig.json, .env template) -&gt; Infrastructure (index.ts, database.ts, socket.ts, errorHandler.ts) -&gt; Models (User.ts, Group.ts, VotingSession.ts) -&gt; Services (movieRecommendationService.ts) -&gt; Routes (auth.ts, groups.ts, voting.ts, movies.ts, users.ts) -&gt; Support (api.md, setup.sh)</p>
<p>But the way cursor just fills each file independently is unnatural. You would see it implement a full file and jump to the next one which is not the way I as a developer would do it as it makes more sense to go over different files to implement something (like auth) and then move to something else (groups).</p>
<p><strong>Generated Frontend vs. Backend</strong></p>
<p>The backend was much more complete than the frontend with more implemented code. The code implemented for the backend was also better structured and configured. Overall, it seemed like the model used up all its planning/context for the backend and just tried to satisfy the prompt minimally for the frotnend.</p>
<p><strong>External API Knowledge</strong></p>
<p>The LLM demonstrates familiarity with the TMDB external API. It appears to know the documentation of the available APIs as it doesn&#39;t ask for clarification or leave any TMDB-related code incomplete.</p>
<hr>
<p><strong>Backend Architectue Concerns</strong></p>
<p>The backend code doesn&#39;t follow best practices. For example, the router directly handles requests without a controller layer:</p>
<pre><code><span class="hljs-comment">// Create a new group</span>
router.post(<span class="hljs-string">'/'</span>, auth, async (req: AuthRequest, res) =&gt; {
  <span class="hljs-keyword">try</span> {
    const { <span class="hljs-built_in">name</span> } = req.body;
    const userId = req.user._id;

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">name</span> || <span class="hljs-built_in">name</span>.trim().length === <span class="hljs-number">0</span>) {
      return res.status(<span class="hljs-number">400</span>).json({ message: <span class="hljs-string">'Group name is required'</span> });
    }

    const <span class="hljs-built_in">group</span> = new <span class="hljs-built_in">Group</span>({
      <span class="hljs-built_in">name</span>: <span class="hljs-built_in">name</span>.trim(),
      <span class="hljs-built_in">owner</span>: userId,
      <span class="hljs-built_in">members</span>: [userId]
    });

    await <span class="hljs-built_in">group</span>.save();

    <span class="hljs-comment">// Add group to user's groups</span>
    await User.findByIdAndUpdate(userId, {
      $push: { groups: <span class="hljs-built_in">group</span>._id }
    });

    res.status(<span class="hljs-number">201</span>).json({
      success: <span class="hljs-literal">true</span>,
      <span class="hljs-built_in">group</span>: {
        id: <span class="hljs-built_in">group</span>._id,
        <span class="hljs-built_in">name</span>: <span class="hljs-built_in">group</span>.<span class="hljs-built_in">name</span>,
        invitationCode: <span class="hljs-built_in">group</span>.invitationCode,
        <span class="hljs-built_in">owner</span>: <span class="hljs-built_in">group</span>.<span class="hljs-built_in">owner</span>,
        <span class="hljs-built_in">members</span>: <span class="hljs-built_in">group</span>.<span class="hljs-built_in">members</span>
      }
    });
  } <span class="hljs-keyword">catch</span> (error) {
    console.error(<span class="hljs-string">'Create group error:'</span>, error);
    res.status(<span class="hljs-number">500</span>).json({ message: <span class="hljs-string">'Failed to create group'</span> });
  }
});
</code></pre><p><strong>Security Vulnerabilities</strong></p>
<p>A critical security issue that was identified was a fallback value for the JWT secret which may be used in production and make the application vulnerable:</p>
<pre><code><span class="hljs-comment">// Generate new token</span>
    const newToken = jwt.sign(
      { <span class="hljs-string">userId:</span> user._id, <span class="hljs-string">email:</span> user.email },
      process.env[<span class="hljs-string">'JWT_SECRET'</span>] || <span class="hljs-string">'fallback_secret'</span>,
      { <span class="hljs-string">expiresIn:</span> <span class="hljs-string">'7d'</span> }
    );
</code></pre><p><strong>Magic Numbers</strong></p>
<p>The backend contains magic numbers without explanation or constants:</p>
<pre><code>    <span class="hljs-comment">// Add popularity and rating factors</span>
    score += (movie.vote_average / <span class="hljs-number">10</span>) * <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Rating factor</span>
    score += Math.min(movie.popularity / <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>) * <span class="hljs-number">0.3</span>; <span class="hljs-comment">// Popularity factor (capped at 1)</span>
</code></pre><hr>
<p><strong>Frontend Generation Order</strong></p>
<p>During the transition to frontend code generation, the model starts from configuration files such as Gradle and manifest files, then continues to the Kotlin source files.</p>
<p><strong>Incomplete Implementation</strong></p>
<p>Code may be left incomplete because much of the context in the beginning is spent on the backend. Below is an example of frontend code not implementing the token transmission to the backend and only leaving comments:</p>
<pre><code><span class="hljs-keyword">val</span> launcher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result -&gt;
        <span class="hljs-keyword">val</span> task = GoogleSignIn.getSignedInAccountFromIntent(result.<span class="hljs-keyword">data</span>)
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> account = task.getResult(ApiException::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
            account?.idToken?.let { token -&gt;
                <span class="hljs-comment">// Handle successful sign-in</span>
                <span class="hljs-comment">// In a real app, you would send this token to your backend</span>
                navController.navigate(<span class="hljs-string">"home"</span>) {
                    popUpTo(<span class="hljs-string">"login"</span>) { inclusive = <span class="hljs-literal">true</span> }
                }
            }
        } <span class="hljs-keyword">catch</span> (e: ApiException) {
            <span class="hljs-comment">// Handle sign-in failure</span>
            isLoading = <span class="hljs-literal">false</span>
        }
    }
</code></pre><p><strong>Mocked Data Instead of API Calls</strong></p>
<p>The incompleteness of the frontend code is more severe in other places. The voting screen, for example, uses mocked data instead of fetching from the backend:</p>
<pre><code>@Composable
fun VotingScreen(
    groupId: String,
    navController: NavController
) {
    var currentMovieIndex by remember { mutableStateOf(<span class="hljs-number">0</span>) }
    var movies by remember { mutableStateOf&lt;List&lt;Movie&gt;&gt;(emptyList()) }
    var isLoading by remember { mutableStateOf(<span class="hljs-literal">true</span>) }

    // Mock data for demonstration
    LaunchedEffect(groupId) {
        // In a real app, you would fetch movies from the API
        <span class="hljs-attr">movies</span> = listOf(
            Movie(
                <span class="hljs-attr">id</span> = <span class="hljs-number">1</span>,
                <span class="hljs-attr">title</span> = <span class="hljs-string">"Inception"</span>,
                <span class="hljs-attr">overview</span> = <span class="hljs-string">"A thief who steals corporate secrets through the use of dream-sharing technology is given the inverse task of planting an idea into the mind of a C.E.O."</span>,
                <span class="hljs-attr">posterPath</span> = <span class="hljs-string">"https://image.tmdb.org/t/p/w500/9gk7adHYeDvHkCSEqAvQNLV5Uge.jpg"</span>,
                <span class="hljs-attr">backdropPath</span> = <span class="hljs-literal">null</span>,
                <span class="hljs-attr">voteAverage</span> = <span class="hljs-number">8.4</span>,
                <span class="hljs-attr">voteCount</span> = <span class="hljs-number">2000</span>,
                <span class="hljs-attr">popularity</span> = <span class="hljs-number">100.0</span>,
                <span class="hljs-attr">releaseDate</span> = <span class="hljs-string">"2010-07-16"</span>,
                <span class="hljs-attr">runtime</span> = <span class="hljs-number">148</span>,
                <span class="hljs-attr">genres</span> = listOf(<span class="hljs-string">"Action"</span>, <span class="hljs-string">"Sci-Fi"</span>, <span class="hljs-string">"Thriller"</span>)
            ),
            Movie(
                <span class="hljs-attr">id</span> = <span class="hljs-number">2</span>,
                <span class="hljs-attr">title</span> = <span class="hljs-string">"The Shawshank Redemption"</span>,
                <span class="hljs-attr">overview</span> = <span class="hljs-string">"Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency."</span>,
                <span class="hljs-attr">posterPath</span> = <span class="hljs-string">"https://image.tmdb.org/t/p/w500/q6y0Go1tsGEsmtFryDOJo3dEmqu.jpg"</span>,
                <span class="hljs-attr">backdropPath</span> = <span class="hljs-literal">null</span>,
                <span class="hljs-attr">voteAverage</span> = <span class="hljs-number">9.3</span>,
                <span class="hljs-attr">voteCount</span> = <span class="hljs-number">2500</span>,
                <span class="hljs-attr">popularity</span> = <span class="hljs-number">95.0</span>,
                <span class="hljs-attr">releaseDate</span> = <span class="hljs-string">"1994-09-23"</span>,
                <span class="hljs-attr">runtime</span> = <span class="hljs-number">142</span>,
                <span class="hljs-attr">genres</span> = listOf(<span class="hljs-string">"Drama"</span>)
            )
        )
        <span class="hljs-attr">isLoading</span> = <span class="hljs-literal">false</span>
    }
</code></pre><p><strong>Missing Backend Integration</strong></p>
<p>The code provided does not talk to the backend at all (e.g., <code>GroupScreen.kt</code>). More generally, none of the API calls are used in the code—they are just defined. The model creates screens but only as UI elements; there&#39;s not much state handling or backend communication. The APIs are also pure interfaces with no client defined to actually invoke them:</p>
<pre><code><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">ApiService</span> {

    <span class="hljs-comment">// Authentication</span>
    <span class="hljs-variable">@POST</span>(<span class="hljs-string">"auth/google"</span>)
    suspend fun authenticateWithGoogle(<span class="hljs-variable">@Body</span> <span class="hljs-attribute">request</span>: GoogleAuthRequest): Response&lt;AuthResponse&gt;

    <span class="hljs-variable">@POST</span>(<span class="hljs-string">"auth/refresh"</span>)
    suspend fun refreshToken(<span class="hljs-variable">@Body</span> <span class="hljs-attribute">request</span>: RefreshTokenRequest): Response&lt;AuthResponse&gt;
</code></pre><p><strong>Unnecessary Code</strong></p>
<p>Unnecessary code was found in the frontend, such as Room database usage while data persistence should be handled through the backend:</p>
<pre><code><span class="hljs-title">package</span> com.movieswipe.<span class="hljs-class"><span class="hljs-keyword">data</span>.model</span>

<span class="hljs-keyword">import</span> androidx.room.Entity
<span class="hljs-keyword">import</span> androidx.room.PrimaryKey

@<span class="hljs-type">Entity</span>(tableName = <span class="hljs-string">"users"</span>)
<span class="hljs-class"><span class="hljs-keyword">data</span> class <span class="hljs-type">User</span>(
    @<span class="hljs-type">PrimaryKey</span>
    <span class="hljs-title">val</span> <span class="hljs-title">id</span>: <span class="hljs-type">String</span>,
    <span class="hljs-title">val</span> <span class="hljs-title">googleId</span>: <span class="hljs-type">String</span>,
    <span class="hljs-title">val</span> <span class="hljs-title">email</span>: <span class="hljs-type">String</span>,
    <span class="hljs-title">val</span> <span class="hljs-title">name</span>: <span class="hljs-type">String</span>,
    <span class="hljs-title">val</span> <span class="hljs-title">picture</span>: <span class="hljs-type">String</span>?,
    <span class="hljs-title">val</span> <span class="hljs-title">preferences</span>: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;,
    <span class="hljs-title">val</span> <span class="hljs-title">groups</span>: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;
)</span>
</code></pre><p><strong>State Management Issues</strong></p>
<p>State is handled in the same place as UI with no separate state handler:</p>
<pre><code><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">GroupsScreen</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span> {
    <span class="hljs-keyword">var</span> groups <span class="hljs-keyword">by</span> remember { mutableStateOf&lt;List&lt;Group&gt;&gt;(emptyList()) }
    <span class="hljs-keyword">var</span> showCreateDialog <span class="hljs-keyword">by</span> remember { mutableStateOf(<span class="hljs-literal">false</span>) }
    <span class="hljs-keyword">var</span> showJoinDialog <span class="hljs-keyword">by</span> remember { mutableStateOf(<span class="hljs-literal">false</span>) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(<span class="hljs-number">16.</span>dp)
    )
</code></pre><hr>
<p><strong>Code Quality Issues</strong></p>
<p><strong>Magic Numbers in UI</strong></p>
<p>Using various magic numbers in the frontend code without constants or explanation:</p>
<pre><code>        Text(
            <span class="hljs-attr">text</span> = <span class="hljs-string">"MovieSwipe"</span>,
            <span class="hljs-attr">fontSize</span> = <span class="hljs-number">32</span>.sp,
            <span class="hljs-attr">fontWeight</span> = FontWeight.Bold,
            <span class="hljs-attr">color</span> = MaterialTheme.colorScheme.primary
        )

        Spacer(<span class="hljs-attr">modifier</span> = Modifier.height(<span class="hljs-number">8</span>.dp))

        Text(
            <span class="hljs-attr">text</span> = <span class="hljs-string">"Find movies everyone will love"</span>,
            <span class="hljs-attr">fontSize</span> = <span class="hljs-number">16</span>.sp,
            <span class="hljs-attr">color</span> = MaterialTheme.colorScheme.onSurfaceVariant
        )
</code></pre><p><strong>Missing Navigation Implementation</strong></p>
<p>Functionality is incomplete in the frontend due to missing navigation logic:</p>
<pre><code>else {
            LazyColumn {
                items(groups) { <span class="hljs-keyword">group</span> <span class="hljs-title">-&gt;
                    GroupCard</span>(
                        <span class="hljs-keyword">group</span> <span class="hljs-title">= group</span>,
                        onGroupClick = { /* Navigate to <span class="hljs-keyword">group</span> <span class="hljs-title">details</span> */ }
                    )
                    Spacer(modifier = Modifier.height(<span class="hljs-number">8</span>.dp))
                }
            }
        }
</code></pre><p>Comments are left as placeholders but no actual implementation for button clicks that should trigger navigation:</p>
<pre><code><span class="hljs-selector-tag">IconButton</span>(onClick = { <span class="hljs-comment">/* End session */</span> }) {
                <span class="hljs-comment">// End session icon</span>
            }
</code></pre><pre><code><span class="hljs-selector-tag">Button</span>(
                    onClick = { <span class="hljs-comment">/* Create new group */</span> },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    <span class="hljs-selector-tag">Text</span>(<span class="hljs-string">"Create New Group"</span>)
                }
</code></pre><p><strong>Missing Authorization Check</strong></p>
<p>There&#39;s no check that the &quot;end voting session&quot; button should only be shown to the group owner, not everyone.</p>
<hr>
<p><strong>Other Observations</strong></p>
<p><strong>Auto-Generated Documentation</strong></p>
<p>It&#39;s noteworthy that some helpful documents were generated by Cursor without explicit request. A README guide was created:</p>
<pre><code><span class="hljs-section"># MovieSwipe Implementation Guide</span>

<span class="hljs-section">## Project Overview</span>

MovieSwipe is a mobile application that helps groups find movies everyone will enjoy through an interactive swiping mechanism and intelligent recommendation algorithm. The project consists of an Android client and a Node.js backend.

<span class="hljs-section">## Architecture</span>

<span class="hljs-section">### Backend (Node.js + TypeScript)</span>
<span class="hljs-bullet">- </span><span class="hljs-strong">**Framework**</span>: Express.js
<span class="hljs-bullet">- </span><span class="hljs-strong">**Database**</span>: MongoDB with Mongoose ODM
<span class="hljs-bullet">- </span><span class="hljs-strong">**Authentication**</span>: Google OAuth + JWT
<span class="hljs-bullet">- </span><span class="hljs-strong">**Real-time**</span>: Socket.io
<span class="hljs-bullet">- </span><span class="hljs-strong">**External API**</span>: TMDB (The Movie Database)
<span class="hljs-bullet">- </span><span class="hljs-strong">**Cloud**</span>: Azure

<span class="hljs-section">### Frontend (Android + Kotlin)</span>
<span class="hljs-bullet">- </span><span class="hljs-strong">**UI Framework**</span>: Jetpack Compose
<span class="hljs-bullet">- </span><span class="hljs-strong">**Language**</span>: Kotlin
<span class="hljs-bullet">- </span><span class="hljs-strong">**Authentication**</span>: Google Sign-In
<span class="hljs-bullet">- </span><span class="hljs-strong">**Networking**</span>: Retrofit + OkHttp
<span class="hljs-bullet">- </span><span class="hljs-strong">**Local Storage**</span>: Room Database
<span class="hljs-bullet">- </span><span class="hljs-strong">**Real-time**</span>: Socket.io Client
<span class="hljs-bullet">- </span><span class="hljs-strong">**Push Notifications**</span>: Firebase Cloud Messaging

<span class="hljs-section">## Key Features Implemented</span>

…
</code></pre><hr>
<p><strong>Build Status</strong></p>
<p>Both the frontend and backend code have build issues which prevented running them to verify functionality.</p>
<hr>
<p><strong>Personal Take</strong></p>
<p>This scenario represents the extreme &quot;vibe coding&quot; approach with a single prompt to generate the entire project with no software engineering knowledge assumed. </p>
<p>Putting myself in shoes of someone who has no idea about programming, I would be fascinated that things are happening with a single prompt. But from a software engineer&#39;s perspective, I was left with some code that I didn&#39;t like and didn&#39;t work, or even if I could make it work, it wouldn&#39;t be the way I do things. The code is also very hard to understand and it&#39;s a lot. Therefore, it felt frustrating and I would rather do it myself.</p>


                        <!-- Main Content of the Page Ends-->
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>