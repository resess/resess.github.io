<!DOCTYPE html><html lang="en-US">

<head>
    <meta charset="UTF-8">
    <title>Expert Developer 2 - Scenario 4 observational notes</title>
    <link rel="stylesheet" href="../../../assets/css/just-the-docs.css"> 
    <link rel="stylesheet" href="../../../assets/css/h4-override.css">
    <script type="text/javascript" src="../../../assets/js/vendor/lunr.min.js"></script> 
    <script type="text/javascript" src="../../../assets/js/just-the-docs.js"></script>
    <script type="text/javascript" src="../../../assets/js/navigation.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

<body>
    <div class="page-wrap">
        <div class="side-bar">
            <div class="site-header"> 
                <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button>
            </div>
            <div class="navigation main-nav js-main-nav">
                <!-- Navigation will be dynamically generated by navigation.js -->
            </div>
            <footer class="site-footer">
                <p class="text-small text-grey-dk-000 mb-4">FSE 2026</p>
            </footer>
        </div>
        <div class="main-content-wrap js-main-content" tabindex="0">
            <div class="main-content">
                <div class="page-header js-page-header">
                    <div class="search">
                        <div class="search-input-wrap"> 
                            <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search " aria-label="Search " autocomplete="off"> 
                            <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon">
                                <title>Search</title> 
                                <g fill-rule="nonzero">
                                    <path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z" />
                                    <path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z" />
                                </g>
                            </svg>
                        </div>
                        <div class="js-search-results search-results-wrap"></div>
                    </div>
                </div>
                <div class="page">
                    <div id="main-content" class="page-content" role="main">
                        <!-- Main Content of the Page Starts-->
                        <h1 id="scenario-1-observational-notes">Expert Developer 2: Scenario 4 Observational Notes</h1>
<p>This scenario evaluates code generation with more fine-grained prompting. While the resulting code is less bloated and easier to work with before reaching an unfixable state, quality issues persist across both frontend and backend.</p>
<hr>
<p><strong>Reduced Code Bloat</strong></p>
<p>While the code still has issues, there&#39;s significantly less code bloat and more opportunity to fix problems before they become unmanageable.</p>
<p><strong>Good Structure</strong></p>
<p>The code is well-structured.</p>
<p><strong>By-Task + High-level Design</strong></p>
<p>Going more fine-grained than features and prompting by-use-case again helps the model, and this time the generated code is better aligned with our rules and setup. It feels like when the agent has fewer worries, it can better apply the rules and implement what is asked of it. Through the generation, there&#39;s less chance of seeing something generated out of place or unwanted. </p>
<p>I think the main reason is that the task is well-defined and so small that it doesn&#39;t leave gaps for the model to fill (atomic in a sense). Generating requires more manual work of prompting and fixing, but that actually feels much better as now you can see a small amount of code generated, review it, understand it, and then fix it. </p>
<p>The model still makes a lot of mistakes, but the mistakes are also small and fixable by just providing logs of errors to the model or explaining the issue. </p>
<p><strong>Frontend vs. Backend</strong></p>
<p>It is still true that there are more things that can go wrong with the frontend. The improvement lies in the greater chance of being able to fix the things that go wrong.</p>
<hr>
<p><strong>Backend Issues</strong></p>
<p><strong>Dead Code</strong></p>
<p>There&#39;s some dead code in session management. For example, <code>signOut</code> calls <code>revokeSessionByIdToken</code>, but <code>authenticateUser</code> never creates a session:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> authenticateUser = <span class="hljs-keyword">async</span> (<span class="hljs-attribute">idToken</span>: <span class="hljs-built_in">string</span>): Promise&lt;AuthenticatedUser&gt; =&gt; {
  <span class="hljs-keyword">const</span> googlePayload = <span class="hljs-keyword">await</span> verifyGoogleToken(idToken);

  <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> getUserByGoogleId(googlePayload.sub);

  <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">const</span> <span class="hljs-attribute">userData</span>: CreateUserData = {
      <span class="hljs-attribute">googleId</span>: googlePayload.sub,
      <span class="hljs-attribute">email</span>: googlePayload.email,
      <span class="hljs-attribute">name</span>: googlePayload.name,
      ...(googlePayload.picture &amp;&amp; { <span class="hljs-attribute">profilePictureUrl</span>: googlePayload.picture }),
    };
    user = <span class="hljs-keyword">await</span> createUser(userData);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attribute">id:</span><span class="hljs-string"> user.id</span>,
    <span class="hljs-attribute">email</span>: user.email,
    <span class="hljs-attribute">name</span>: user.name,
    ...(user.profilePictureUrl &amp;&amp; { <span class="hljs-attribute">profilePictureUrl</span>: user.profilePictureUrl }),
  };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> signOut = <span class="hljs-keyword">async</span> (<span class="hljs-attribute">idToken</span>: <span class="hljs-built_in">string</span>): Promise&lt;<span class="hljs-keyword">void</span>&gt; =&gt; {
  <span class="hljs-comment">// ID tokens are stateless JWT tokens that cannot be revoked via Google's revocation endpoint.</span>
  <span class="hljs-comment">// They expire naturally. Attempting to revoke an ID token may fail, so we skip this step.</span>
  <span class="hljs-comment">// The revocation endpoint is primarily for access tokens and refresh tokens.</span>

  <span class="hljs-comment">// Attempt to revoke the session in our database if it exists</span>
  <span class="hljs-comment">// <span class="hljs-doctag">Note:</span> It's okay if the session doesn't exist - it might have never been created or already expired</span>
  <span class="hljs-comment">// Sign out is still considered successful even without a session record</span>
  <span class="hljs-keyword">const</span> revokedSession = <span class="hljs-keyword">await</span> revokeSessionByIdToken(idToken);
  <span class="hljs-comment">// If revokedSession is null, it means the session didn't exist, which is acceptable</span>
};
</code></pre><p><strong>Magic Numbers</strong></p>
<p>Magic numbers without constants or documentation:</p>
<pre><code> <span class="hljs-keyword">score </span>+= movie.vote_average * <span class="hljs-number">0</span>.<span class="hljs-number">1</span><span class="hljs-comment">;</span>
</code></pre><p><strong>Repeated Code Patterns</strong></p>
<p>The same issue with repeated code patterns persists:</p>
<pre><code>export const startVotingSessionController = async (req: Request, res: Response): Promise&lt;void&gt; =&gt; {
  const groupId = req.params.groupId as <span class="hljs-built_in">string</span> | undefined;
  const userId = req.query.userId as <span class="hljs-built_in">string</span> | undefined;

  <span class="hljs-keyword">if</span> (!userId) {
    res.<span class="hljs-built_in">status</span>(<span class="hljs-number">401</span>).json({ <span class="hljs-built_in">error</span>: 'User authentication required' });
    <span class="hljs-built_in">return</span>;
  }

  <span class="hljs-keyword">if</span> (!groupId) {
    res.<span class="hljs-built_in">status</span>(<span class="hljs-number">400</span>).json({ <span class="hljs-built_in">error</span>: 'Group ID <span class="hljs-built_in">is</span> required' });
    <span class="hljs-built_in">return</span>;
  }

  try {
    const result = await startVotingSession(groupId, userId);

    <span class="hljs-keyword">if</span> (!result.notificationSent) {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">200</span>).json({
        ...result.groupDetails,
        message: 'You started the voting session successfully but members could <span class="hljs-keyword">not</span> be notified. You might want to contact them directly.',
      });
      <span class="hljs-built_in">return</span>;
    }

    res.<span class="hljs-built_in">status</span>(<span class="hljs-number">200</span>).json(result.groupDetails);
  } <span class="hljs-built_in">catch</span> (<span class="hljs-built_in">error</span>) {
    const errorMessage = <span class="hljs-built_in">error</span> instanceof Error ? <span class="hljs-built_in">error</span>.message : 'An unexpected <span class="hljs-built_in">error</span> occurred';

    <span class="hljs-keyword">if</span> (errorMessage === 'This group has been deleted.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">404</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'Only the group owner can start a voting session.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">403</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'A voting session <span class="hljs-built_in">is</span> already <span class="hljs-keyword">in</span> progress <span class="hljs-keyword">for</span> this group.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">400</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'Failed to <span class="hljs-built_in">load</span> movies. Please try again.') {
      try {
        const groupDetails = await getGroupDetails(groupId, userId);
        res.<span class="hljs-built_in">status</span>(<span class="hljs-number">200</span>).json({
          ...groupDetails,
          <span class="hljs-built_in">error</span>: 'Failed to <span class="hljs-built_in">load</span> movies. Please try again.',
        });
      } <span class="hljs-built_in">catch</span> (detailsError) {
        res.<span class="hljs-built_in">status</span>(<span class="hljs-number">500</span>).json({ <span class="hljs-built_in">error</span>: 'Failed to <span class="hljs-built_in">load</span> movies. Please try again.' });
      }
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'Failed to start voting session. Please try again.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">500</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    res.<span class="hljs-built_in">status</span>(<span class="hljs-number">500</span>).json({ <span class="hljs-built_in">error</span>: 'Failed to start voting session. Please try again.' });
  }
};

export const getNextMovieToVoteOnController = async (req: Request, res: Response): Promise&lt;void&gt; =&gt; {
  try {
    const groupId = req.params.groupId as <span class="hljs-built_in">string</span> | undefined;
    const userId = req.query.userId as <span class="hljs-built_in">string</span> | undefined;

    <span class="hljs-keyword">if</span> (!userId) {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">401</span>).json({ <span class="hljs-built_in">error</span>: 'User authentication required' });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (!groupId) {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">400</span>).json({ <span class="hljs-built_in">error</span>: 'Group ID <span class="hljs-built_in">is</span> required' });
      <span class="hljs-built_in">return</span>;
    }

    const result = await getNextMovieToVoteOn(groupId, userId);

    res.<span class="hljs-built_in">status</span>(<span class="hljs-number">200</span>).json(result);
  } <span class="hljs-built_in">catch</span> (<span class="hljs-built_in">error</span>) {
    const errorMessage = <span class="hljs-built_in">error</span> instanceof Error ? <span class="hljs-built_in">error</span>.message : 'An unexpected <span class="hljs-built_in">error</span> occurred';

    <span class="hljs-keyword">if</span> (errorMessage === 'This group has been deleted.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">404</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'The voting session has ended.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">400</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'You are no longer a <span class="hljs-built_in">member</span> of this group.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">403</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    <span class="hljs-keyword">if</span> (errorMessage === 'Failed to <span class="hljs-built_in">load</span> next movie. Please try again.') {
      res.<span class="hljs-built_in">status</span>(<span class="hljs-number">500</span>).json({ <span class="hljs-built_in">error</span>: errorMessage });
      <span class="hljs-built_in">return</span>;
    }

    res.<span class="hljs-built_in">status</span>(<span class="hljs-number">500</span>).json({ <span class="hljs-built_in">error</span>: 'An unexpected <span class="hljs-built_in">error</span> occurred' });
  }
};
</code></pre><p>The code style is also error-prone, missing a <code>return</code> statement would result in different behavior.</p>
<p><strong>Sequential API Calls in Loops</strong></p>
<p>There&#39;s a for loop where fetch is called sequentially, which is detrimental to performance. Either batch requests or parallel requests should be used instead:</p>
<pre><code>   for (const { <span class="hljs-keyword">movie </span>} of scoredMovies) {
      <span class="hljs-meta">if</span> (<span class="hljs-keyword">selectedMovies.length </span>&gt;= TARGET_MOVIES) {
        <span class="hljs-keyword">break;
</span>      }

      const <span class="hljs-keyword">movieDetails </span>= await fetchMovieDetailsFromTmdb(<span class="hljs-keyword">movie.id);
</span>      <span class="hljs-meta">if</span> (<span class="hljs-keyword">movieDetails </span>&amp;&amp; <span class="hljs-keyword">movieDetails.runtime) </span>{
        const <span class="hljs-keyword">selectedMovie </span>= convertTmdbMovieToSelectedMovie(<span class="hljs-keyword">movieDetails);
</span>        <span class="hljs-keyword">selectedMovies.push(selectedMovie);
</span>      } <span class="hljs-meta">else</span> {
        const <span class="hljs-keyword">selectedMovie </span>= convertTmdbMovieToSelectedMovie(<span class="hljs-keyword">movie);
</span>        <span class="hljs-keyword">selectedMovies.push(selectedMovie);
</span>      }
    }
</code></pre><p><strong>Missing Caching</strong></p>
<p>There&#39;s no caching when getting movies or genres:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getGenres = <span class="hljs-keyword">async</span> (): <span class="hljs-built_in">Promise</span>&lt;Genre[]&gt; =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> genres = <span class="hljs-keyword">await</span> getAllGenres();

    <span class="hljs-comment">// TMDB typically returns around 19-20 genres for movies</span>
    <span class="hljs-comment">// If we have fewer than 10, refresh from TMDB to ensure we have all genres</span>
    <span class="hljs-keyword">const</span> MIN_EXPECTED_GENRES = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">if</span> (genres.length === <span class="hljs-number">0</span> || genres.length &lt; MIN_EXPECTED_GENRES) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> tmdbGenres = <span class="hljs-keyword">await</span> fetchGenresFromTmdb();
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">await</span> upsertGenres(tmdbGenres);
          genres = <span class="hljs-keyword">await</span> getAllGenres();
        } <span class="hljs-keyword">catch</span> (dbError) {
          <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Error saving genres to database:'</span>, dbError);
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Failed to load movie genres. Please try again.'</span>);
        }
      } <span class="hljs-keyword">catch</span> (tmdbError) {
        <span class="hljs-keyword">if</span> (tmdbError <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
          <span class="hljs-keyword">if</span> (tmdbError.message.includes(<span class="hljs-string">'Failed to load movie genres'</span>)) {
            <span class="hljs-keyword">throw</span> tmdbError;
          }
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Failed to load movie genres. Please try again.'</span>);
      }
    }

    <span class="hljs-keyword">return</span> genres.map(<span class="hljs-function">(<span class="hljs-params">genre: GenreDocument</span>) =&gt;</span> ({
      <span class="hljs-attr">id</span>: genre.genreId,
      <span class="hljs-attr">name</span>: genre.name,
    }));
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
      <span class="hljs-keyword">if</span> (error.message.includes(<span class="hljs-string">'Failed to load movie genres'</span>)) {
        <span class="hljs-keyword">throw</span> error;
      }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Failed to load movie genres. Please try again.'</span>);
  }
};
</code></pre><hr>
<p><strong>Hardcoded Secrets</strong></p>
<p>Hardcoded secret for Google authentication:</p>
<pre><code>        <span class="hljs-keyword">val</span> gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(<span class="hljs-string">"your_google_client_id"</span>) <span class="hljs-comment">// please update with your google client ID</span>
            .requestEmail()
            .build()
</code></pre><p><strong>Repeated Error Handling</strong></p>
<p>Error handling is repeated extensively without abstraction:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDataSourceImpl</span> : <span class="hljs-type">UserDataSource {</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()
        .baseUrl(Constants.BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> apiService = retrofit.create(UserApiService::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>

    <span class="hljs-keyword">override</span> suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">signIn</span><span class="hljs-params">(idToken: <span class="hljs-type">String</span>)</span></span>: Result&lt;AuthenticatedUser&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> request = SignInRequest(idToken)
            <span class="hljs-keyword">val</span> user = apiService.signIn(request)
            Result.success(user)
        } <span class="hljs-keyword">catch</span> (e: HttpException) {
            <span class="hljs-keyword">val</span> errorMessage = <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> errorBody = e.response()?.errorBody()?.string()
                <span class="hljs-keyword">val</span> gson = Gson()
                <span class="hljs-keyword">val</span> errorResponse = gson.fromJson(errorBody, ErrorResponse::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
                errorResponse.error ?: getDefaultErrorMessage(e.code())
            } <span class="hljs-keyword">catch</span> (parseException: Exception) {
                Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Failed to parse error response"</span>, parseException)
                getDefaultErrorMessage(e.code())
            }
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"HTTP error: <span class="hljs-subst">${e.code()}</span>, message: <span class="hljs-subst">$errorMessage</span>"</span>)
            Result.failure(Exception(errorMessage))
        } <span class="hljs-keyword">catch</span> (e: IOException) {
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Network error"</span>, e)
            Result.failure(Exception(<span class="hljs-string">"Google authentication service temporarily unavailable. Please try again."</span>))
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Unexpected error"</span>, e)
            Result.failure(Exception(<span class="hljs-string">"Authentication service temporarily unavailable. Please try again."</span>))
        }
    }

    <span class="hljs-keyword">override</span> suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">signOut</span><span class="hljs-params">(idToken: <span class="hljs-type">String</span>)</span></span>: Result&lt;<span class="hljs-built_in">Unit</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> request = SignOutRequest(idToken)
            apiService.signOut(request)
            Result.success(<span class="hljs-built_in">Unit</span>)
        } <span class="hljs-keyword">catch</span> (e: HttpException) {
            <span class="hljs-keyword">val</span> errorMessage = <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> errorBody = e.response()?.errorBody()?.string()
                <span class="hljs-keyword">val</span> gson = Gson()
                <span class="hljs-keyword">val</span> errorResponse = gson.fromJson(errorBody, ErrorResponse::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
                errorResponse.error ?: getDefaultSignOutErrorMessage(e.code())
            } <span class="hljs-keyword">catch</span> (parseException: Exception) {
                Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Failed to parse error response"</span>, parseException)
                getDefaultSignOutErrorMessage(e.code())
            }
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"HTTP error: <span class="hljs-subst">${e.code()}</span>, message: <span class="hljs-subst">$errorMessage</span>"</span>)
            Result.failure(Exception(errorMessage))
        } <span class="hljs-keyword">catch</span> (e: IOException) {
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Network error"</span>, e)
            Result.failure(Exception(<span class="hljs-string">"Authentication service temporarily unavailable, cannot sign out. Please try again."</span>))
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Unexpected error"</span>, e)
            Result.failure(Exception(<span class="hljs-string">"Authentication service temporarily unavailable, cannot sign out. Please try again."</span>))
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDefaultErrorMessage</span><span class="hljs-params">(code: <span class="hljs-type">Int</span>)</span></span>: String {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (code) {
            <span class="hljs-number">503</span> -&gt; <span class="hljs-string">"Google authentication service temporarily unavailable. Please try again."</span>
            <span class="hljs-number">401</span> -&gt; <span class="hljs-string">"Authentication unsuccessful. Please try again."</span>
            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">"Authentication service temporarily unavailable. Please try again."</span>
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDefaultSignOutErrorMessage</span><span class="hljs-params">(code: <span class="hljs-type">Int</span>)</span></span>: String {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (code) {
            <span class="hljs-number">503</span> -&gt; <span class="hljs-string">"Authentication service temporarily unavailable, cannot sign out. Please try again."</span>
            <span class="hljs-number">400</span> -&gt; <span class="hljs-string">"Session not found or already revoked"</span>
            <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">"Authentication service temporarily unavailable, cannot sign out. Please try again."</span>
        }
    }

    <span class="hljs-keyword">override</span> suspend <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">registerFcmToken</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, fcmToken: <span class="hljs-type">String</span>)</span></span>: Result&lt;<span class="hljs-built_in">Unit</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">val</span> request = RegisterFcmTokenRequest(userId, fcmToken)
            apiService.registerFcmToken(request)
            Result.success(<span class="hljs-built_in">Unit</span>)
        } <span class="hljs-keyword">catch</span> (e: HttpException) {
            <span class="hljs-keyword">val</span> errorMessage = <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> errorBody = e.response()?.errorBody()?.string()
                <span class="hljs-keyword">val</span> gson = Gson()
                <span class="hljs-keyword">val</span> errorResponse = gson.fromJson(errorBody, ErrorResponse::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
                errorResponse.error ?: <span class="hljs-string">"Failed to register FCM token. Please try again."</span>
            } <span class="hljs-keyword">catch</span> (parseException: Exception) {
                Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Failed to parse error response"</span>, parseException)
                <span class="hljs-string">"Failed to register FCM token. Please try again."</span>
            }
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"HTTP error: <span class="hljs-subst">${e.code()}</span>, message: <span class="hljs-subst">$errorMessage</span>"</span>)
            Result.failure(Exception(errorMessage))
        } <span class="hljs-keyword">catch</span> (e: IOException) {
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Network error"</span>, e)
            Result.failure(Exception(<span class="hljs-string">"Failed to register FCM token. Please try again."</span>))
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            Log.e(<span class="hljs-string">"UserDataSource"</span>, <span class="hljs-string">"Unexpected error"</span>, e)
            Result.failure(Exception(<span class="hljs-string">"Failed to register FCM token. Please try again."</span>))
        }
    }
}
</code></pre><p><strong>Duplicated Components</strong></p>
<p>Sometimes the same component is defined twice instead of being reusable. For example, <code>GenreCheckBoxItem</code> exists in both <code>GenrePreferencesScreen</code> and <code>JoinGroupGenrePreferencesScreen</code>:</p>
<p><img src="../../../data/rq2/observational-notes/expert2/data/scenario4/image1.png" alt="" width="400"><br></p>
<p><strong>Empty Files</strong></p>
<p>There are multiple empty files that were never implemented.</p>
<p><strong>Unused Dependencies</strong></p>
<p><code>CreateGroupViewModel</code> has <code>UserRepository</code> injected but never uses it:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateGroupViewModel</span></span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> movieRepository: MovieRepository,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> votingGroupRepository: VotingGroupRepository,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepository: UserRepository
) : ViewModel() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow(CreateGroupUiState())
    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;CreateGroupUiState&gt; = _uiState.asStateFlow()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">openGroupNameDialog</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(
            showGroupNameDialog = <span class="hljs-literal">true</span>,
            groupName = <span class="hljs-string">""</span>,
            groupNameError = <span class="hljs-literal">null</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">closeGroupNameDialog</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(
            showGroupNameDialog = <span class="hljs-literal">false</span>,
            groupName = <span class="hljs-string">""</span>,
            groupNameError = <span class="hljs-literal">null</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateGroupName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> {
        _uiState.value = _uiState.value.copy(
            groupName = name,
            groupNameError = <span class="hljs-literal">null</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validateAndProceedToGenres</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> trimmedName = _uiState.value.groupName.trim()

        <span class="hljs-keyword">if</span> (trimmedName.isEmpty()) {
            _uiState.value = _uiState.value.copy(
                groupNameError = <span class="hljs-string">"Group name is required and must be 3-30 alphanumeric characters."</span>
            )
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">if</span> (trimmedName.length &lt; <span class="hljs-number">3</span> || trimmedName.length &gt; <span class="hljs-number">30</span>) {
            _uiState.value = _uiState.value.copy(
                groupNameError = <span class="hljs-string">"Group name is required and must be 3-30 alphanumeric characters."</span>
            )
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">if</span> (!trimmedName.matches(Regex(<span class="hljs-string">"^[a-zA-Z0-9]+$"</span>))) {
            _uiState.value = _uiState.value.copy(
                groupNameError = <span class="hljs-string">"Group name is required and must be 3-30 alphanumeric characters."</span>
            )
            <span class="hljs-keyword">return</span>
        }

        _uiState.value = _uiState.value.copy(
            showGroupNameDialog = <span class="hljs-literal">false</span>,
            showGenrePreferencesScreen = <span class="hljs-literal">true</span>,
            groupName = trimmedName,
            groupNameError = <span class="hljs-literal">null</span>,
            genresError = <span class="hljs-literal">null</span>
        )

        loadGenres()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadGenres</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (_uiState.value.genres.isNotEmpty()) {
            <span class="hljs-keyword">return</span>
        }

        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(
                isLoadingGenres = <span class="hljs-literal">true</span>,
                genresError = <span class="hljs-literal">null</span>
            )

            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> genresList = movieRepository.getGenres()
                _uiState.value = _uiState.value.copy(
                    genres = genresList,
                    isLoadingGenres = <span class="hljs-literal">false</span>,
                    genresError = <span class="hljs-literal">null</span>
                )
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                <span class="hljs-keyword">val</span> errorMessage = <span class="hljs-keyword">when</span> {
                    e.message?.contains(<span class="hljs-string">"Failed to load movie genres"</span>, ignoreCase = <span class="hljs-literal">true</span>) == <span class="hljs-literal">true</span> -&gt; {
                        <span class="hljs-string">"Failed to load movie genres. Please try again."</span>
                    }
                    <span class="hljs-keyword">else</span> -&gt; {
                        <span class="hljs-string">"Failed to load movie genres. Please try again."</span>
                    }
                }
                _uiState.value = _uiState.value.copy(
                    isLoadingGenres = <span class="hljs-literal">false</span>,
                    genresError = errorMessage
                )
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">retryLoadGenres</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(
            genres = emptyList(),
            genresError = <span class="hljs-literal">null</span>
        )
        loadGenres()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toggleGenreSelection</span><span class="hljs-params">(genreId: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-keyword">val</span> currentSelected = _uiState.value.selectedGenres.toMutableSet()
        <span class="hljs-keyword">if</span> (currentSelected.contains(genreId)) {
            currentSelected.remove(genreId)
        } <span class="hljs-keyword">else</span> {
            currentSelected.add(genreId)
        }
        _uiState.value = _uiState.value.copy(
            selectedGenres = currentSelected,
            createGroupError = <span class="hljs-literal">null</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">goBackToGroupNameDialog</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(
            showGenrePreferencesScreen = <span class="hljs-literal">false</span>,
            showGroupNameDialog = <span class="hljs-literal">true</span>,
            createGroupError = <span class="hljs-literal">null</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createGroup</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span> {
        <span class="hljs-keyword">if</span> (_uiState.value.selectedGenres.isEmpty()) {
            _uiState.value = _uiState.value.copy(
                createGroupError = <span class="hljs-string">"Genre selection is required. Please choose at least two preferred movie genres."</span>
            )
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">if</span> (_uiState.value.selectedGenres.size &lt; <span class="hljs-number">2</span>) {
            _uiState.value = _uiState.value.copy(
                createGroupError = <span class="hljs-string">"Genre selection is required. Please choose at least two preferred movie genres."</span>
            )
            <span class="hljs-keyword">return</span>
        }

        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(
                isLoadingCreateGroup = <span class="hljs-literal">true</span>,
                createGroupError = <span class="hljs-literal">null</span>,
                userId = userId
            )

            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> genreList = _uiState.value.selectedGenres.toList()
                <span class="hljs-keyword">val</span> createdGroup = votingGroupRepository.createGroup(
                    name = _uiState.value.groupName,
                    ownerId = userId,
                    genrePreferences = genreList
                )

                _uiState.value = _uiState.value.copy(
                    isLoadingCreateGroup = <span class="hljs-literal">false</span>,
                    showGenrePreferencesScreen = <span class="hljs-literal">false</span>,
                    groupName = <span class="hljs-string">""</span>,
                    selectedGenres = emptySet(),
                    createGroupError = <span class="hljs-literal">null</span>,
                    createdGroupId = createdGroup.id
                )
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                <span class="hljs-keyword">val</span> errorMessage = <span class="hljs-keyword">when</span> {
                    e.message?.contains(<span class="hljs-string">"Group name is required"</span>, ignoreCase = <span class="hljs-literal">true</span>) == <span class="hljs-literal">true</span> -&gt; {
                        <span class="hljs-string">"Group name is required and must be 3-30 alphanumeric characters."</span>
                    }
                    e.message?.contains(<span class="hljs-string">"Genre selection is required"</span>, ignoreCase = <span class="hljs-literal">true</span>) == <span class="hljs-literal">true</span> -&gt; {
                        <span class="hljs-string">"Genre selection is required. Please choose at least two preferred movie genres."</span>
                    }
                    e.message?.contains(<span class="hljs-string">"Failed to create group"</span>, ignoreCase = <span class="hljs-literal">true</span>) == <span class="hljs-literal">true</span> -&gt; {
                        <span class="hljs-string">"Failed to create group. Please try again."</span>
                    }
                    <span class="hljs-keyword">else</span> -&gt; {
                        <span class="hljs-string">"Failed to create group. Please try again."</span>
                    }
                }
                _uiState.value = _uiState.value.copy(
                    isLoadingCreateGroup = <span class="hljs-literal">false</span>,
                    createGroupError = errorMessage
                )
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">retryCreateGroup</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> userId = _uiState.value.userId
        <span class="hljs-keyword">if</span> (userId != <span class="hljs-literal">null</span>) {
            createGroup(userId)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resetState</span><span class="hljs-params">()</span></span> {
        _uiState.value = CreateGroupUiState()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clearGroupNameError</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(groupNameError = <span class="hljs-literal">null</span>)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clearGenresError</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(genresError = <span class="hljs-literal">null</span>)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clearCreateGroupError</span><span class="hljs-params">()</span></span> {
        _uiState.value = _uiState.value.copy(createGroupError = <span class="hljs-literal">null</span>)
    }
}
</code></pre><p><strong>Missing Caching and Lazy Loading</strong></p>
<p>The frontend also lacks caching or lazy loading for images and other heavy data.</p>
<p><strong>Complex LaunchedEffect Logic</strong></p>
<p><code>LaunchedEffect</code> with heavy and complex logic, which is not a good practice:</p>
<pre><code>               LaunchedEffect(authUiState.isAuthenticated, attemptingSilentSignIn, hasNotificationIntent) {
                    // IMPORTANT: <span class="hljs-keyword">If</span> we have a notification intent <span class="hljs-keyword">and</span> are attempting silent sign-<span class="hljs-keyword">in</span>, <span class="hljs-keyword">do</span> <span class="hljs-keyword">NOT</span> navigate here
                    // Let the notification navigation LaunchedEffects handle it
                    <span class="hljs-keyword">if</span> (hasNotificationIntent &amp;&amp; attemptingSilentSignIn) {
                        Log.d(<span class="hljs-string">"FCM"</span>, <span class="hljs-string">"Skipping default navigation - notification intent detected and attempting silent sign-in: $navigateTo"</span>)
                        <span class="hljs-keyword">return</span>@LaunchedEffect
                    }

                    // IMPORTANT: <span class="hljs-keyword">If</span> we have a notification intent, <span class="hljs-keyword">do</span> <span class="hljs-keyword">NOT</span> navigate here
                    // Let the notification navigation LaunchedEffects handle it
                    <span class="hljs-keyword">if</span> (hasNotificationIntent) {
                        Log.d(<span class="hljs-string">"FCM"</span>, <span class="hljs-string">"Skipping default navigation - notification intent detected: $navigateTo"</span>)
                        <span class="hljs-keyword">return</span>@LaunchedEffect
                    }

                    <span class="hljs-keyword">if</span> (authUiState.isAuthenticated) {
                        // Only navigate to GroupList <span class="hljs-keyword">if</span> we<span class="hljs-symbol">'re</span> <span class="hljs-keyword">not</span> handling a notification
                        <span class="hljs-keyword">if</span> (!handledNotificationNavigation) {
                            // Only navigate <span class="hljs-keyword">if</span> we<span class="hljs-symbol">'re</span> <span class="hljs-keyword">not</span> already on the correct screen
                            val currentRoute = navController.currentDestination?.route
                            val isOnGroupDetails = currentRoute?.startsWith(<span class="hljs-string">"group_details/"</span>) == <span class="hljs-literal">true</span>
                            <span class="hljs-keyword">if</span> (currentRoute != Screen.GroupList.route &amp;&amp; 
                                currentRoute != Screen.GroupDetails(<span class="hljs-string">"{groupId}"</span>).route &amp;&amp;
                                !isOnGroupDetails) {
                                navController.navigate(Screen.GroupList.route) {
                                    popUpTo(Screen.Authentication.route) { inclusive = <span class="hljs-literal">true</span> }
                                }
                            }
                        }
                        // Register FCM token after successful sign-<span class="hljs-keyword">in</span>
                        authUiState.userId?.let { userId -&gt;
                            // Store userId <span class="hljs-keyword">in</span> SharedPreferences <span class="hljs-keyword">for</span> notification service <span class="hljs-keyword">access</span>
                            val prefs = getSharedPreferences(<span class="hljs-string">"movieswipe_prefs"</span>, Context.MODE_PRIVATE)
                            prefs.edit().putString(<span class="hljs-string">"current_user_id"</span>, userId).apply()
                            Log.d(<span class="hljs-string">"FCM"</span>, <span class="hljs-string">"Stored userId in SharedPreferences: $userId"</span>)

                            registerFcmToken(userId)
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!authUiState.isLoading &amp;&amp; !attemptingSilentSignIn &amp;&amp; !authUiState.signOutSuccess) {
                        // Only navigate to Authentication <span class="hljs-keyword">if</span> we<span class="hljs-symbol">'re</span> <span class="hljs-keyword">not</span> already there, <span class="hljs-keyword">not</span> attempting silent sign-<span class="hljs-keyword">in</span>, <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> signing <span class="hljs-keyword">out</span> successfully
                        // (<span class="hljs-keyword">when</span> sign <span class="hljs-keyword">out</span> succeeds, we close the app instead <span class="hljs-keyword">of</span> navigating)
                        val currentRoute = navController.currentDestination?.route
                        <span class="hljs-keyword">if</span> (currentRoute != Screen.Authentication.route) {
                            navController.navigate(Screen.Authentication.route) {
                                popUpTo(Screen.GroupList.route) { inclusive = <span class="hljs-literal">true</span> }
                            }
                        }
                    }
                }
</code></pre><hr>
<p><strong>Personal Take</strong></p>
<p>Overall, while the code is easier to get functional and less bloated, there are still multiple quality issues. <strong>More fine-grained prompting doesn&#39;t seem to resolve the underlying code quality problems.</strong></p>
<p>While going by-task is overall better than by-feature, I can see that grouping tasks to cover more than just one feature can be beneficial in some cases. However, this only feels like it works for the backend, where the model seems to be better prepared for certain prompts. For instance, asking the model to implement different parts of CRUD routes one by one is less convenient for it than just asking for the whole CRUD at once. </p>
<p>In the frontend, a similar pattern exists but to a lesser extent. Doing sign in and sign out together seems more suited for the model than doing them separately. These are things that developers understand when seeing the generation and can optimize for later, but to start with, having a more fine-grained setup is always safer than a coarse-grained one.</p>
<p>I belive the generic frameworks on how to use agentic tools should be toward more specification and more granularity but developers should keep an eye out for specific optimizations based on their own use cases.</p>

                        <!-- Main Content of the Page Ends-->
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>