<!DOCTYPE html><html lang="en-US">

<head>
    <meta charset="UTF-8">
    <title>Expert Developer 2 - Scenario 3 observational notes</title>
    <link rel="stylesheet" href="../../../assets/css/just-the-docs.css"> 
    <link rel="stylesheet" href="../../../assets/css/h4-override.css">
    <script type="text/javascript" src="../../../assets/js/vendor/lunr.min.js"></script> 
    <script type="text/javascript" src="../../../assets/js/just-the-docs.js"></script>
    <script type="text/javascript" src="../../../assets/js/navigation.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    

<body>
    <div class="page-wrap">
        <div class="side-bar">
            <div class="site-header"> 
                <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button>
            </div>
            <div class="navigation main-nav js-main-nav">
                <!-- Navigation will be dynamically generated by navigation.js -->
            </div>
            <footer class="site-footer">
                <p class="text-small text-grey-dk-000 mb-4">FSE 2026</p>
            </footer>
        </div>
        <div class="main-content-wrap js-main-content" tabindex="0">
            <div class="main-content">
                <div class="page-header js-page-header">
                    <div class="search">
                        <div class="search-input-wrap"> 
                            <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search " aria-label="Search " autocomplete="off"> 
                            <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon">
                                <title>Search</title> 
                                <g fill-rule="nonzero">
                                    <path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z" />
                                    <path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z" />
                                </g>
                            </svg>
                        </div>
                        <div class="js-search-results search-results-wrap"></div>
                    </div>
                </div>
                <div class="page">
                    <div id="main-content" class="page-content" role="main">
                        <!-- Main Content of the Page Starts-->
                        <h1 id="scenario-1-observational-notes">Expert Developer 2: Scenario 3 Observational Notes</h1>
<p>This scenario evaluates code generation using a feature-by-feature approach. While this provides Cursor with more freedom, e.g., the ability to build and verify the backend, it also results in code bloat and persistent quality issues.</p>
<hr>
<p><strong>Code Generation Process</strong></p>
<p><strong>Generation Approach</strong></p>
<p>Going feature by feature to generate results in code similar to Scenario 2. Cursor has more freedom and sometimes tries building the backend to ensure there are no build issues.</p>
<p><strong>By-Feature Generation</strong>
In this scenario we provided all the information needed to describe the app, which was better detailed than previous scenarios, and on top of that used by-feature generation which leads to more fine-grained tasks. Below are the observations in by-feature generation:</p>
<ul>
<li><p>Generation-wise, the backend seems less difficult for the model to generate code for, but for the frontend there seem to be more struggles. This can stem from both the fact that the model doesn&#39;t know much Kotlin/Android and also the inherently greater difficulty of frontend generation. If I had limited budget, I would use more prompts for the frontend and fewer prompts for the backend. Even though both are low quality and don&#39;t work, it seems the frontend is suffering more.</p>
</li>
<li><p>The workflow of using AI is more natural and closer to what I would do myself, but the generated code is still unbearable, both in terms of size and the amount of issues happening each time.</p>
</li>
<li><p>Some features seem to be implemented more easily by the model and some seem to be more difficult. This variability is expected, but what makes a feature easy or hard from an LLM perspective can be difficult to detect before actually prompting the model. For instance, features that include setting up something are more difficult for the model than other features. In the frontend, when implementing auth, the model has to think about setting up Retrofit to call the backend, which doesn&#39;t happen in the following features. In contrast, if the feature is mostly simple CRUD in the backend, it appears to be easier for the model. The difficulty effect, and anticipating it when balancing the prompts is a challenge for both the model and the person prompting the model. </p>
</li>
</ul>
<p><strong>Code Bloat</strong></p>
<p>There&#39;s more code generated, which is mostly unnecessary and useless. For example, multiple service files exist that are not at the same level of abstraction. For instance, we could have a movieService handling both recommendation and fetching of movies. Also, the database service could be distributed in different services:</p>
<p><img src="../../../data/rq2/observational-notes/expert2/data/scenario3/image1.png" alt="" width="300"><br></p>
<hr>
<p><strong>Security Vulnerabilities in Dependencies</strong></p>
<p>When running <code>npm install</code>, multiple security issues are reported:</p>
<pre><code><span class="hljs-number">91</span> packages are looking for funding
  <span class="hljs-keyword">run</span><span class="bash"> `npm fund` <span class="hljs-keyword">for</span> details
</span>
<span class="hljs-number">8</span> vulnerabilities (<span class="hljs-number">3</span> low, <span class="hljs-number">3</span> moderate, <span class="hljs-number">1</span> high, <span class="hljs-number">1</span> critical)

To address all issues, <span class="hljs-keyword">run</span><span class="bash">:
</span>  npm audit fix
</code></pre><p>Packages have even more security issues than previous scenarios.</p>
<p><strong>Successful Build</strong></p>
<p>Despite the security issues, the backend has no build issues:</p>
<pre><code><span class="hljs-symbol">npm</span> run <span class="hljs-keyword">build
</span>
&gt; <span class="hljs-keyword">movieswipe-backend@1.0.0 </span><span class="hljs-keyword">build
</span>&gt; tsc
</code></pre><hr>
<p><strong>Backend Issues</strong></p>
<p><strong>Repeated Error Handling Pattern</strong></p>
<p>Multiple APIs follow the same pattern of error handling without abstraction:</p>
<pre><code> async getRecommendations(req: Request, res: Response): Promise&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
…
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) {
      console.<span class="hljs-keyword">error</span>(<span class="hljs-string">'Get recommendations error:'</span>, <span class="hljs-keyword">error</span>);
      res.status(<span class="hljs-number">500</span>).json({
        success: <span class="hljs-keyword">false</span>,
        <span class="hljs-keyword">error</span>: 'Failed to fetch recommendations'
      });
    }
  }

  async toggleFavorite(req: Request, res: Response): Promise&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
     …
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) {
      console.<span class="hljs-keyword">error</span>(<span class="hljs-string">'Toggle favorite error:'</span>, <span class="hljs-keyword">error</span>);
      res.status(<span class="hljs-number">500</span>).json({
        success: <span class="hljs-keyword">false</span>,
        <span class="hljs-keyword">error</span>: 'Failed to toggle favorite'
      });
    }
  }

  async getFavorites(req: Request, res: Response): Promise&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      …
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) {
      console.<span class="hljs-keyword">error</span>(<span class="hljs-string">'Get favorites error:'</span>, <span class="hljs-keyword">error</span>);
      res.status(<span class="hljs-number">500</span>).json({
        success: <span class="hljs-keyword">false</span>,
        <span class="hljs-keyword">error</span>: 'Failed to fetch favorites'
      });
    }
  }
}
</code></pre><p><strong>Logic Bugs</strong></p>
<p>The code contains logic bugs. For instance, in <code>getMovieSelectionResults</code>:</p>
<pre><code> async getMovieSelectionResults(sessionId: <span class="hljs-built_in">string</span>): Promise&lt;{
    sessionId: <span class="hljs-built_in">string</span>;
    groupId: <span class="hljs-built_in">string</span>;
    selectedMovie: Movie;
    votingResults: <span class="hljs-built_in">Array</span>&lt;{
      movie: Movie;
      yesVotes: <span class="hljs-built_in">number</span>;
      noVotes: <span class="hljs-built_in">number</span>;
      totalVotes: <span class="hljs-built_in">number</span>;
      approvalRate: <span class="hljs-built_in">number</span>;
      score: <span class="hljs-built_in">number</span>;
    }&gt;;
    totalParticipants: <span class="hljs-built_in">number</span>;
    totalVotesCast: <span class="hljs-built_in">number</span>;
    endTime: <span class="hljs-built_in">Date</span>;
    sessionDuration: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// in minutes</span>
  }&gt; {
    <span class="hljs-keyword">const</span> session = await VotingSessionModel.findById(sessionId);
    <span class="hljs-keyword">if</span> (!session) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Voting session not found'</span>);
    }

    <span class="hljs-keyword">if</span> (session.status !== <span class="hljs-string">'completed'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Voting session is not completed'</span>);
    }

    <span class="hljs-keyword">if</span> (!session.selectedMovie) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No movie has been selected for this session'</span>);
    }

    <span class="hljs-comment">// Get group details to count participants</span>
    <span class="hljs-keyword">const</span> group = await <span class="hljs-keyword">this</span>.groupService.getGroupById(session.groupId);
    <span class="hljs-keyword">if</span> (!group) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Group not found'</span>);
    }

    <span class="hljs-keyword">const</span> totalParticipants = group.members.length + <span class="hljs-number">1</span>; <span class="hljs-comment">// +1 for owner</span>
</code></pre><p>The code adds one for the owner, but in <code>createGroup</code>:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">createGroup</span>(<span class="hljs-params">name: <span class="hljs-keyword">string</span>, ownerId: <span class="hljs-keyword">string</span></span>): Promise&lt;IGroup&gt; </span>{
    <span class="hljs-keyword">const</span> invitationCode = generateInvitationCode();

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">group</span> = <span class="hljs-keyword">new</span> GroupModel({
      name,
      ownerId,
      invitationCode,
      members: [{
        userId: ownerId,
        joinedAt: <span class="hljs-keyword">new</span> Date(),
        preferences: []
      }],
      isActive: <span class="hljs-literal">true</span>
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">group</span>.save();
  }
</code></pre><p><strong>The owner is already part of the members array, resulting in double-counting!</strong></p>
<p><strong>Incomplete Service Implementation</strong></p>
<p>The code returns popular movies instead of using the actual <code>movieRecommendationService.ts</code> that exists in the codebase:</p>
<pre><code> <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">getRecommendations</span>(<span class="hljs-params">req: Request, res: Response</span>): Promise&lt;<span class="hljs-keyword">void</span>&gt; </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> { groupId } = req.<span class="hljs-keyword">params</span>;
      <span class="hljs-keyword">const</span> { limit = <span class="hljs-number">20</span> } = req.query;

      <span class="hljs-comment">// For now, return popular movies as recommendations</span>
      <span class="hljs-comment">// This will be enhanced in the future with group preference-based recommendations</span>
      <span class="hljs-keyword">const</span> movies = <span class="hljs-keyword">await</span> tmdbService.getPopularMovies(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">const</span> limitedMovies = movies.slice(<span class="hljs-number">0</span>, parseInt(limit <span class="hljs-keyword">as</span> <span class="hljs-keyword">string</span>));

      res.status(<span class="hljs-number">200</span>).json({
        success: <span class="hljs-literal">true</span>,
        data: {
          movies: limitedMovies,
          groupId,
          note: <span class="hljs-string">'Currently showing popular movies. Group-based recommendations coming soon.'</span>
        }
      });
    } <span class="hljs-keyword">catch</span> (error) {
      console.error(<span class="hljs-string">'Get recommendations error:'</span>, error);
      res.status(<span class="hljs-number">500</span>).json({
        success: <span class="hljs-literal">false</span>,
        error: <span class="hljs-string">'Failed to fetch recommendations'</span>
      });
    }
  }
</code></pre><p><strong>Unimplemented Functions</strong></p>
<p>In <code>socketService</code>, there&#39;s an <code>authenticateUser</code> function that isn&#39;t implemented:</p>
<pre><code> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title">authenticateUser</span>(<span class="hljs-params">token: <span class="hljs-keyword">string</span></span>): Promise&lt;any&gt; </span>{
    <span class="hljs-comment">// Implement JWT verification here</span>
    <span class="hljs-comment">// This is a placeholder - implement actual JWT verification</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
</code></pre><p><strong>Magic Numbers</strong></p>
<p>Hardcoded values without constants:</p>
<pre><code>hasMore: movies.<span class="hljs-built_in">length</span> === <span class="hljs-number">20</span>
</code></pre><p><strong>Type Safety Issues</strong></p>
<p>Incomplete typing and type safety issues:</p>
<pre><code><span class="hljs-keyword">const</span> userId = (req <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).user.id;
</code></pre><p><strong>Code Duplication</strong></p>
<p>Extensive code duplication in controllers:</p>
<pre><code><span class="hljs-keyword">async</span> createSession(req: Request, <span class="hljs-attr">res</span>: Response): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> { groupId } = req.body;
      <span class="hljs-keyword">const</span> userId = (req <span class="hljs-keyword">as</span> any).user.id;

      <span class="hljs-keyword">if</span> (!groupId) {
        res.status(<span class="hljs-number">400</span>).json({
          <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">error</span>: <span class="hljs-string">'Group ID is required'</span>
        });
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> votingService.createSession(groupId, userId);

      res.status(<span class="hljs-number">201</span>).json({
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">id</span>: (session <span class="hljs-keyword">as</span> any)._id,
          <span class="hljs-attr">groupId</span>: session.groupId,
          <span class="hljs-attr">status</span>: session.status,
          <span class="hljs-attr">movies</span>: session.movies,
          <span class="hljs-attr">votes</span>: session.votes,
          <span class="hljs-attr">startTime</span>: session.startTime,
          <span class="hljs-attr">endTime</span>: session.endTime,
          <span class="hljs-attr">selectedMovie</span>: session.selectedMovie,
          <span class="hljs-attr">createdAt</span>: session.createdAt,
          <span class="hljs-attr">updatedAt</span>: session.updatedAt
        }
      });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Create session error:'</span>, error);
      res.status(<span class="hljs-number">500</span>).json({
        <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">error</span>: error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? error.message : <span class="hljs-string">'Failed to create voting session'</span>
      });
    }
  }

  <span class="hljs-comment">/**
   * GET /api/voting/sessions/active/:groupId
   * Get active voting session for a group
   */</span>
  <span class="hljs-keyword">async</span> getActiveSession(req: Request, <span class="hljs-attr">res</span>: Response): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> { groupId } = req.params;
      <span class="hljs-keyword">const</span> userId = (req <span class="hljs-keyword">as</span> any).user.id;

      <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> votingService.getActiveSession(groupId);

      <span class="hljs-keyword">if</span> (!session) {
        res.status(<span class="hljs-number">404</span>).json({
          <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">error</span>: <span class="hljs-string">'No active voting session found for this group'</span>
        });
        <span class="hljs-keyword">return</span>;
      }

      res.status(<span class="hljs-number">200</span>).json({
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">id</span>: (session <span class="hljs-keyword">as</span> any)._id,
          <span class="hljs-attr">groupId</span>: session.groupId,
          <span class="hljs-attr">status</span>: session.status,
          <span class="hljs-attr">movies</span>: session.movies,
          <span class="hljs-attr">votes</span>: session.votes,
          <span class="hljs-attr">startTime</span>: session.startTime,
          <span class="hljs-attr">endTime</span>: session.endTime,
          <span class="hljs-attr">selectedMovie</span>: session.selectedMovie,
          <span class="hljs-attr">createdAt</span>: session.createdAt,
          <span class="hljs-attr">updatedAt</span>: session.updatedAt
        }
      });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Get active session error:'</span>, error);
      res.status(<span class="hljs-number">500</span>).json({
        <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">error</span>: <span class="hljs-string">'Failed to fetch active session'</span>
      });
    }
  }

  <span class="hljs-comment">/**
   * POST /api/voting/sessions/:sessionId/start
   * Start a voting session
   */</span>
  <span class="hljs-keyword">async</span> startSession(req: Request, <span class="hljs-attr">res</span>: Response): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> { sessionId } = req.params;
      <span class="hljs-keyword">const</span> userId = (req <span class="hljs-keyword">as</span> any).user.id;

      <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> votingService.startSession(sessionId, userId);

      res.status(<span class="hljs-number">200</span>).json({
        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">id</span>: (session <span class="hljs-keyword">as</span> any)._id,
          <span class="hljs-attr">groupId</span>: session.groupId,
          <span class="hljs-attr">status</span>: session.status,
          <span class="hljs-attr">movies</span>: session.movies,
          <span class="hljs-attr">votes</span>: session.votes,
          <span class="hljs-attr">startTime</span>: session.startTime,
          <span class="hljs-attr">endTime</span>: session.endTime,
          <span class="hljs-attr">selectedMovie</span>: session.selectedMovie,
          <span class="hljs-attr">createdAt</span>: session.createdAt,
          <span class="hljs-attr">updatedAt</span>: session.updatedAt
        },
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Voting session started successfully'</span>
      });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Start session error:'</span>, error);
      res.status(<span class="hljs-number">500</span>).json({
        <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">error</span>: error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? error.message : <span class="hljs-string">'Failed to start voting session'</span>
      });
    }
  }
</code></pre><p>The same result pattern and error handling is duplicated throughout.</p>
<p><strong>Persistent Security Issues</strong></p>
<p>The same security issue with fallback values persists:</p>
<pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> appConfig: AppConfig = {
...
  jwtSecret: <span class="hljs-built_in">process</span>.env.JWT_SECRET || <span class="hljs-string">'your-super-secret-jwt-key'</span>,
...
};
</code></pre><p><strong>Performance Issues</strong></p>
<p>Performance issues when using sockets with large payloads:</p>
<pre><code>// Sends full movies<span class="hljs-built_in"> array </span>(20 movies with all details) to all clients:
this.io.to(`group:${session.groupId}`).emit('session:started', {
  sessionId,
  movies: session.movies
});
</code></pre><hr>
<p><strong>Frontend Issues</strong></p>
<p><strong>Faulty Owner Check Logic</strong></p>
<p>The frontend has obvious issues. For example, checking the first member in the group list to be the owner which is a fragile assumption:</p>
<pre><code>if (<span class="hljs-keyword">group</span>.ownerId == <span class="hljs-keyword">group</span>.members.firstOrNull()?.<span class="hljs-keyword">user</span>Id) {
    Button(<span class="hljs-keyword">on</span>Click = { viewModel.generateInviteCode(<span class="hljs-keyword">group</span>.id) }) {
</code></pre><p><strong>Build Errors</strong></p>
<p>There are inconsistencies in the code resulting in build/compile errors like argument mismatches:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">composable</span><span class="hljs-params">(Screen.Group.route)</span></span> { GroupScreen(
    onVoteSession = { sessionId -&gt; navController.navigate(Screen<span class="hljs-selector-class">.VotingWithSession</span><span class="hljs-selector-class">.createRoute</span>(sessionId)) }
) }
</code></pre><pre><code><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">GroupScreen</span><span class="hljs-params">(
    viewModel: <span class="hljs-type">GroupViewModel</span> = viewModel()</span></span>
) {
</code></pre><p>There are also missing imports in some files.</p>
<p><strong>Incomplete Functionality</strong></p>
<p>While the functionality is more complete, some features are still missing. For example, the leave group implementation is incomplete.</p>
<p><strong>Magic Numbers and Hardcoding</strong></p>
<p>Magic numbers for swipe threshold:</p>
<pre><code><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(swipeOffset &gt; <span class="hljs-number">200</span>)</span> {
    <span class="hljs-title">votingViewModel</span>.<span class="hljs-title">vote</span><span class="hljs-params">(<span class="hljs-string">"yes"</span>)</span></span>
</code></pre><p>Other magic numbers and hardcoding:</p>
<pre><code>valueRange = <span class="hljs-number">1</span>f.<span class="hljs-number">.10</span>f,
steps = <span class="hljs-number">8</span>
Color(<span class="hljs-number">0xFFE3F2FD</span>) 
modifier = Modifier.height(<span class="hljs-number">180.</span>dp)
</code></pre><p><strong>Unused Code</strong></p>
<p>Unused code for dependency injection:</p>
<pre><code><span class="hljs-keyword">package</span> com.example.movieswipe.di

<span class="hljs-meta">@Module</span>
<span class="hljs-meta">@InstallIn</span>(<span class="hljs-type">SingletonComponent</span>::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AppModule</span> </span>{
    <span class="hljs-comment">// Provide dependencies here</span>
}
</code></pre><p>Unused imports throughout the code.</p>
<p><strong>Hardcoded Secrets</strong></p>
<p>Hardcoding secrets in config files:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AuthConfig</span> </span>{
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Replace with your actual Google OAuth client ID</span>
    const <span class="hljs-keyword">val</span> <span class="hljs-type">GOOGLE_CLIENT_ID</span> = <span class="hljs-string">"YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com"</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Replace with your actual backend base URL</span>
    const <span class="hljs-keyword">val</span> <span class="hljs-type">BACKEND_BASE_URL</span> = <span class="hljs-string">"http://10.0.2.2:3001/api"</span> <span class="hljs-comment">// Emulator localhost</span>
}
</code></pre><p><strong>Manifest Misconfiguration</strong></p>
<p>Missing internet permission in the manifest:</p>
<pre><code><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span><span class="hljs-meta">?&gt;</span></span>
<span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>
        <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">...</span></span>
</code></pre><p><strong>Insecure Token Storage</strong></p>
<p>JWT not encrypted when saved:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveJwt</span><span class="hljs-params">(jwt: <span class="hljs-type">String</span>)</span></span> {
    prefs.edit().putString(<span class="hljs-string">"jwt"</span>, jwt).apply()
}
</code></pre><p><strong>Blocking Network Calls</strong></p>
<p>Performing blocking network calls (highly detrimental to performance, may cause UI hangs):</p>
<pre><code>val <span class="hljs-built_in">response</span> = client.newCall(<span class="hljs-built_in">request</span>).<span class="hljs-keyword">execute</span>()
</code></pre><hr>
<p><strong>Personal Take</strong></p>
<p>Easier to work with but still not quite there. The process of coming up with the prompts is way too demanding and still not enough for the model to generate the expected output. There are still a lot of things that the model has to decide for itself, which means just knowing what to do is not enough and we need to tell the model how to do things as well. As it seems, the model can&#39;t find the best way to do things on its own.</p>

                        <!-- Main Content of the Page Ends-->
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>